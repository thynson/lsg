//
// Copyright (C) 2012 LAN Xingcan
//
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
//

#include "dumper.hh"
#include "lsg.hh"

using namespace std;
using namespace lsg;

dumper::dumper(dfa_machine *m)
	: m_machine(m)
{
}

dumper::~dumper()
{
}

void dumper::dump(std::ostream &os)
{

	const vector<dfa_state*> &v = m_machine->get_states();
	vector<dfa_state*>::const_iterator i;

	dump_prolog(os, v);

	for (i = v.begin(); i != v.end(); ++i)
	{
		dump_state(os, *i);
	}

	dump_postscript(os);
}

pretty_dumper::pretty_dumper(dfa_machine *m)
	: dumper(m)
{
}

pretty_dumper::~pretty_dumper()
{
}

void pretty_dumper::dump_state(std::ostream &os, dfa_state *s)
{
	os << " State " << s->get_id() << ":\n";

	const map<unsigned, dfa_state*> &m = s->get_transit_table();
	map<unsigned, dfa_state*>::const_iterator i;

	for (i = m.begin(); i != m.end(); ++i)
	{
		unsigned input = i->first;
		dfa_state *target = i->second;

		if (input > LSG_NONE)
		{
			os << "  Satisfy rule " << (input - LSG_NONE) << endl;
			/* Dummy input for rule is always larger then LSG_NONE,
			 * so all the possible input have been handled. And the rule id
			 * increases rule by rule, the former rule have priority than
			 * latter, so after dump one satisfied rule, we just break the
			 * loop, inspite of any other rules */
			break;
		}
		else
		{
			os << "  On input " << input << " : goto "
			   << target->get_id() << endl;
		}
	}
}

void pretty_dumper::dump_prolog(std::ostream &os, const vector<dfa_state*> &vs)
{
	os << "State: " << vs.size() << endl
	   << "Transition graph:" << endl;
}

void pretty_dumper::dump_postscript(std::ostream &os)
{

}

c_dumper::c_dumper(dfa_machine *m, const map<string, unsigned> &rm)
	: dumper(m)
	, m_rule_map(rm)
{
}

c_dumper::~c_dumper()
{
}

void c_dumper::dump_header(ostream &os)
{
	os << "/* The following code was generated by lsg */" << endl;

	os << "#ifndef __LSG_GENERATED__\n"
	   << "#define __LSG_GENERATED__\n"
	   << endl;

	os << "enum {\n";
	map<string, unsigned>::iterator i = m_rule_map.begin();

	for ( ; ; )
	{
		os << " " << i->first << " = " << i->second;

		if (++i != m_rule_map.end())
		{
			os << ",\n";
		}
		else
		{
			os << "\n};\n";
			break;
		}

	}

	os << "#endif" << endl;;
}

void c_dumper::dump_state(ostream &os, dfa_state *s)
{
	os << "lsg_" << s->get_id() << ":" << endl;

	const map<unsigned, dfa_state*> &m = s->get_transit_table();

	if (m.empty())
		return ;

	bool have_next_input = m.begin()->first < LSG_NONE;
	bool have_satisfy_rule = m.rbegin()->first > LSG_NONE;

	if (have_next_input)
	{
		os << " {" << endl
		   << "  if (ptr == buff + size) {" << endl
		   << "   scanner->state = " << s->get_id() << ";" << endl
		   << "   scanner->ptr = ptr;" << endl
		   << "   return 0;" << endl
		   << "  }" << endl
		   << "  switch (*ptr++) {" << endl;

		for (map<unsigned, dfa_state*>::const_iterator i = m.begin();
			i != m.end(); ++i)
		{
			if (i->first < LSG_NONE)
			{
				os << "  case " << i->first << ": "
				   << "goto lsg_" << i->second->get_id() << ";" << endl;
			}
			else
			{
				os << "  default:" << endl
				   << "   scanner->ptr = --ptr;" << endl
				   << "   scanner->state = 0;" << endl
				   << "   return " << (i->first - LSG_NONE) << ";" << endl;
				break;
			}
		}

		if (!have_satisfy_rule)
		{
			os << "  default:" << endl
			   << "   scanner->ptr = --ptr;" << endl
			   << "   scanner->state = 0;" << endl
			   << "   return 0;" << endl;
		}

		os << "  }\n";
		os << " }\n";
	}
	else
	{
		os << " scanner->state = 0; " << endl
		   << " scanner->ptr = ptr; " << endl
		   << " return " << (m.begin()->first  - LSG_NONE) << ";"
		   << endl;
	}

}

void c_dumper::dump_prolog(ostream &os, const vector<dfa_state*> &vs)
{
	// Generate Prolog coments
	os << "/* The following code is generated by lsg */" << endl
	   << "#include \"lsg-scanner.h\"" << endl;


	os << "int lsg_machine(struct lsg_scanner_t *scanner)" << endl;

	os << "{" << endl
	   << " register int state = scanner->state;" << endl
	   << " register const char *ptr = scanner->ptr;" << endl
	   << " register const char *buff = scanner->buff;" << endl
	   << " size_t size = scanner->buff_size;" << endl
	   << " if (size == 0) {" << endl
	   << "  switch(state) {" << endl;

	for (vector<dfa_state*>::const_iterator i = vs.begin();
		i < vs.end(); ++i)
	{
		os << "  case " << (*i)->get_id() << ":" << endl;
		const map<unsigned, dfa_state*> &m = (*i)->get_transit_table();

		if (m.begin()->first >= LSG_NONE) {
			// This is an acceptable state
			os << "   return " << (m.begin()->first - LSG_NONE)
			   << ";" << endl;
		} else {
			os << "   return 0;" << endl;
		}
	}


	os  << "  default: return 0;" << endl
		<< "  }" << endl
		<< " } else { " << endl
		<< "  switch(state) {" << endl;

	for (vector<dfa_state*>::const_iterator i = vs.begin();
		i != vs.end(); ++i)
	{
		int id = (*i)->get_id();
		os << "  case " << id << ": goto lsg_" << id << ";" << endl;
	}

	os << "  }" << endl
	   << " }" << endl
	   << "lsg_start:" << endl;
}

void c_dumper::dump_postscript(ostream &os)
{
	os << "}"; // End of scanner function

	os << "/* The above code is generated by lsg */" << endl;

}
